use super::frontend::parser::Expression;
use crate::compiler::frontend::reader::datum::Datum;

/// As every compiler, we do have different phases.
/// Each phase consumes a some code representation which was in turn
/// generated by the phase before. It might produce a different representation itself.
///
/// This module provides one entry point for the representations which different
/// parts of the compiler might depend on.

/// Representation of core scheme.
///
/// This is a fully expanded collection of expressions.
/// It is produced by the `CoreParser`.
///
#[derive(Clone, Debug)]
pub struct CoreAST {
    pub expressions: Vec<Expression>,
}

impl CoreAST {
    pub fn new(expressions: Vec<Expression>) -> Self {
        Self { expressions }
    }
}

/// The `SexpAST` is parsed s-expressions, that are produced by the `reader`.
#[derive(Clone, Debug)]
pub struct SexpAST {
    sexps: Vec<Datum>,
}

impl SexpAST {
    pub fn new(sexps: Vec<Datum>) -> Self {
        Self { sexps }
    }

    pub fn to_vec(&self) -> &Vec<Datum> {
        &self.sexps
    }

    /// Get only the very first datum of this ast.
    pub fn first(&self) -> &Datum {
        debug_assert!(!self.sexps.is_empty());
        &self.sexps[0]
    }
}
